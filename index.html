<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Decode — Target: Bitcoin</title>
<style>
  :root{
    --bg:#050607;
    --accent:#2aff9b;
    --muted:#8b8f95;
    --gutter:10px;
    --min-tile-w: 340px; /* min terminal width before we add a new row */
    --toolbar-h: 46px;
  }
  html,body{height:100%;margin:0;background:#0a0c0e;color:var(--accent);font-family:ui-monospace,Menlo,Monaco,Consolas,monospace;overflow:hidden}
  .app{height:100vh;display:flex;flex-direction:column}
  .toolbar{height:var(--toolbar-h);display:flex;align-items:center;gap:10px;padding:8px 12px;background:rgba(255,255,255,.03);border-bottom:1px solid rgba(255,255,255,.05)}
  .brand{font-weight:700;color:#bfffdc}
  .control{margin-left:auto;display:flex;gap:8px;align-items:center}
  .btn,.num{background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);color:var(--accent);border-radius:8px;padding:6px 10px;font-size:13px}
  .btn{cursor:pointer}
  .num{width:72px;background:transparent}
  .grid{flex:1;display:grid;gap:var(--gutter);padding:12px;box-sizing:border-box;overflow:hidden}
  .tile{position:relative;background:linear-gradient(180deg,rgba(255,255,255,.03),rgba(255,255,255,.01));border:1px solid rgba(255,255,255,.06);border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,.4), inset 0 1px 0 rgba(255,255,255,.04);overflow:hidden}
  .title{position:absolute;left:8px;top:6px;font-size:12px;color:var(--muted);z-index:2}
  canvas{position:absolute;inset:0;display:block}
</style>
</head>
<body>
<div class="app">
  <div class="toolbar">
    <div class="brand">Auto Decoding - Progressive</div>
    <div style="color:var(--muted);font-size:13px">Brute-Force Mode</div>
    <div class="control">
      <label style="color:var(--muted);font-size:13px">Terminals</label>
      <input id="termCount" class="num" type="number" min="1" max="16" value="6" />
      <button class="btn" id="apply">Apply</button>
      <button class="btn" id="pauseAll">Pause</button>
      <button class="btn" id="resumeAll">Resume</button>
      <button class="btn" id="randomize">Burst</button>
    </div>
  </div>

  <div id="grid" class="grid"></div>
</div>

<script>
/* =======================
   Canvas Terminal Engine
   ======================= */

const SAMPLE = [
  'sudo nmap -sS -p- 10.0.{R}.{R}',
  'ssh root@{R}.{R}.{R}.{R} -p {N}',
  'auth: token {HEX} verified for uid {UID}',
  '[{TIME}] TRACE → {IP} via gw 192.168.{R}.{R}',
  'git fetch && git reset --hard origin/main',
  'python3 scan.py --fast --threads=12',
  '[INFO] Processed {N} packets in {N}ms',
  'watchdog: heartbeat lost on eth{R}',
  'DB_WRITE trace:"session {ISO} start"',
  'alloc(0x{HEX}, {N}) → OK',
  'payload:[{HEX}{HEX}{HEX}]',
  'SERVICE firewall={BOOL} status={STAT}',
  'rm -rf /tmp/cache_{UID}/*',
  'while true; do echo ping; sleep 1; done',
  'chunks={N} size={N} bytes user={UID}'
];

function rnd(a=0,b=1){ return Math.floor(Math.random()*(b-a+1))+a }
function hex(len=4){ let s=''; for(let i=0;i<len;i++) s += Math.floor(Math.random()*16).toString(16); return s }
function repl(s){
  return s.replaceAll('{R}', ()=>rnd(1,254))
          .replaceAll('{N}', ()=>rnd(1,9999))
          .replaceAll('{UID}',()=>rnd(1000,9999))
          .replaceAll('{HEX}',()=>hex(4))
          .replaceAll('{ISO}',()=>new Date().toISOString())
          .replaceAll('{TIME}',()=>new Date().toLocaleTimeString())
          .replaceAll('{BOOL}',()=>Math.random()<.5?'true':'false')
          .replaceAll('{STAT}',()=>['OK','WARN','FAIL'][rnd(0,2)])
          .replaceAll('{IP}',()=>['10.0.0.1','172.16.8.4','203.120.45.2'][rnd(0,2)])
}

class CanvasTerm {
  constructor(id, mount){
    this.id=id; this.mount=mount; this.paused=false;
    this.canvas=document.createElement('canvas');
    this.canvas.setAttribute('aria-label','terminal');
    this.ctx=this.canvas.getContext('2d');
    this.mount.className='tile';
    this.mount.innerHTML = `<div class="title">root@node-${String(id).padStart(2,'0')}</div>`;
    this.mount.appendChild(this.canvas);

    // drawing config
    this.fontSize=13; this.lineGap=4; this.pad=14;
    this.family='ui-monospace, Menlo, Monaco, Consolas, monospace';
    this.cursorOn=true; this.cursorTick=0;

    // ring buffer
    this.lines=[]; this.maxRows=10; this.typingQueue=[];
    this._resizeObserver = new ResizeObserver(()=>this.resize());
    this._resizeObserver.observe(this.mount);
    this.resize();

    // generators
    this.interval = setInterval(()=> this.enqueueRandom(), rnd(350,900));
    requestAnimationFrame(()=>this.draw());
  }

  resize(){
    // fit canvas to tile (with devicePixelRatio for crisp text)
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const w = this.mount.clientWidth;
    const h = this.mount.clientHeight;
    this.canvas.width = Math.floor(w*dpr);
    this.canvas.height = Math.floor(h*dpr);
    this.canvas.style.width = w+'px';
    this.canvas.style.height = h+'px';
    const ctx=this.ctx;
    ctx.setTransform(dpr,0,0,dpr,0,0);

    // compute rows that fit
    this.ctx.font = `${this.fontSize}px ${this.family}`;
    const lineH = this.fontSize + this.lineGap;
    this.maxRows = Math.max(3, Math.floor((h - this.pad*2)/lineH));
    // make sure buffer not longer than rows
    if(this.lines.length > this.maxRows) this.lines = this.lines.slice(-this.maxRows);
  }

  enqueueRandom(){
    if(this.paused) return;
    const txt = repl(SAMPLE[rnd(0,SAMPLE.length-1)]);
    this.enqueueTyping(txt);
    // occasional burst
    if(Math.random()<0.12){
      const n=rnd(2,5);
      for(let i=0;i<n;i++) setTimeout(()=>this.enqueueTyping(repl(SAMPLE[rnd(0,SAMPLE.length-1)])), i*120);
    }
  }

  enqueueTyping(text){
    // create a typing job: progressively add characters
    const job = { text, idx:0 };
    this.typingQueue.push(job);
  }

  draw(){
    const ctx=this.ctx, W=this.canvas.width/ (window.devicePixelRatio||1), H=this.canvas.height/(window.devicePixelRatio||1);
    // clear
    ctx.clearRect(0,0,W,H);

    // background
    const grd = ctx.createLinearGradient(0,0,0,H);
    grd.addColorStop(0,'rgba(255,255,255,.03)');
    grd.addColorStop(1,'rgba(255,255,255,.01)');
    ctx.fillStyle = grd; ctx.fillRect(0,0,W,H);

    // advance typing
    if(!this.paused && this.typingQueue.length){
      const job = this.typingQueue[0];
      const speed = rnd(2,4); // chars per frame step
      job.idx = Math.min(job.idx + speed, job.text.length);
      const cur = job.text.slice(0, job.idx);
      this._applyTyped(cur);
      if(job.idx>=job.text.length) this.typingQueue.shift();
    }

    // draw lines
    ctx.font = `${this.fontSize}px ${this.family}`;
    ctx.textBaseline='top';
    const lineH = this.fontSize + this.lineGap;
    let y = this.pad;

    for(let i=0;i<this.lines.length;i++){
      const ln = this.lines[i];
      // simple tinting
      if(ln.type==='ip'){ ctx.fillStyle = '#ff9ccd'; }
      else if(ln.type==='kw'){ ctx.fillStyle = '#9bdfff'; }
      else if(ln.type==='str'){ ctx.fillStyle = '#ffd28a'; }
      else if(ln.type==='comment'){ ctx.fillStyle = '#5a6b66'; }
      else { ctx.fillStyle = '#c9ffe6'; }

      ctx.fillText(ln.text, this.pad, y);
      y += lineH;
    }

    // cursor
    this.cursorTick++;
    if(this.cursorTick%35===0) this.cursorOn=!this.cursorOn;
    if(this.cursorOn){
      const curY = this.pad + (this.lines.length-1)*lineH;
      const curX = this.pad + ctx.measureText((this.lines[this.lines.length-1]?.text || '').replace(/\u2588$/,'')).width + 2;
      ctx.fillStyle = '#2aff9b';
      ctx.fillRect(curX, curY+2, 8, this.fontSize-2);
    }

    requestAnimationFrame(()=>this.draw());
  }

  _applyTyped(partial){
    // ensure last line is the line being typed; overwrite it
    let type='plain';
    if(/\d+\.\d+\.\d+\.\d+/.test(partial)) type='ip';
    else if(/^(sudo|ssh|git|python|rm|alloc|watchdog)/.test(partial)) type='kw';
    else if(partial.includes('"')||partial.includes("'")||partial.includes('payload')) type='str';
    else if(partial.startsWith('[')) type='comment';

    // start a new line if last is finalized (no trailing cursor char)
    if(!this.lines.length || this.lines[this.lines.length-1].final){
      this.lines.push({text:'', type, final:false});
    }
    const cur = this.lines[this.lines.length-1];
    cur.text = partial;
    cur.type = type;

    // if fully finished previously, mark final and add an empty line slot
    // (handled when queue advances to next job)
    // keep within rows
    if(this.lines.length > this.maxRows) this.lines = this.lines.slice(-this.maxRows);
  }

  finalizeLine(){
    if(this.lines.length){
      this.lines[this.lines.length-1].final = true;
      if(this.lines.length > this.maxRows) this.lines = this.lines.slice(-this.maxRows);
      // add a blank line placeholder so next typing replaces it
      this.lines.push({text:'', type:'plain', final:false});
      if(this.lines.length > this.maxRows) this.lines = this.lines.slice(-this.maxRows);
    }
  }

  burst(n=5){ for(let i=0;i<n;i++) this.enqueueTyping(repl(SAMPLE[rnd(0,SAMPLE.length-1)])); }
  pause(){ this.paused=true; }
  resume(){ this.paused=false; }
  destroy(){ clearInterval(this.interval); this._resizeObserver.disconnect(); this.mount.innerHTML=''; }
}

/* ===========
   Layout
   =========== */
const grid = document.getElementById('grid');
let terms = [];

function layoutGrid(){
  const W = grid.clientWidth;
  const H = grid.clientHeight;
  const gutter = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gutter')) || 10;
  const minW = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--min-tile-w')) || 340;

  // columns based on min width
  let cols = Math.max(1, Math.floor((W + gutter) / (minW + gutter)));
  cols = Math.min(cols, terms.length || 1);
  const rows = Math.ceil((terms.length || 1)/cols);

  grid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;

  // compute tile height so all rows fit exactly (minus gaps)
  const tileH = Math.max(150, Math.floor( (H - gutter*(rows-1)) / rows ));
  for(const t of terms){
    t.mount.style.height = tileH + 'px';
    // triggering resize observer will recompute rows in canvas
  }
}

function build(n){
  // cleanup
  terms.forEach(t=>t.destroy());
  terms = [];
  grid.innerHTML = '';

  // create tiles
  for(let i=0;i<n;i++){
    const tile = document.createElement('div');
    grid.appendChild(tile);
    const term = new CanvasTerm(i+1, tile);
    terms.push(term);
  }
  layoutGrid();
}

// keep grid sized to viewport (no page scroll)
function fitViewport(){
  const app = document.querySelector('.app');
  app.style.height = window.innerHeight + 'px';
  layoutGrid();
}

window.addEventListener('resize', fitViewport);
build(parseInt(document.getElementById('termCount').value,10));
fitViewport();

/* ===========
   Controls
   =========== */
document.getElementById('apply').addEventListener('click', ()=>{
  const n = Math.max(1, Math.min(16, parseInt(document.getElementById('termCount').value,10)||6));
  document.getElementById('termCount').value = n;
  build(n);
  fitViewport();
});
document.getElementById('pauseAll').addEventListener('click', ()=> terms.forEach(t=>t.pause()));
document.getElementById('resumeAll').addEventListener('click', ()=> terms.forEach(t=>t.resume()));
document.getElementById('randomize').addEventListener('click', ()=> terms.forEach(t=> t.burst(rnd(3,7))));
</script>
</body>
</html>
